#pragma config(Motor,  port2,           ForwardLeft,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           ForwardRight,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           BackwardLeft,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           BackwardRight, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           LauncherLeft,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           LauncherRight, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           Intake,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           Debug,         tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*const float pK = 0; const float iK = 0; const float dK = 0;
float Proportion; float Integral; float Derivative;*/

const float Gain = 0.1;	const float Tolerance = 0.1;

float Input; float Revolution;
float Output; float pOutput = 0;
float Error; float pError = Input; const float dTime = 0.05;

void Drive(int LVertical, int RVertical) {
	motor[ForwardLeft] = LVertical; 	motor[ForwardRight] = RVertical;
	motor[BackwardLeft] = LVertical;	motor[BackwardRight] = RVertical;
}

int Sensitivity(int Input, int Other) {
	if (Input * Other <= -16 * 127)
		return Input/2;
	return Input;
}

int Threshold(int Input) {
		if (abs(Input) > 16)
			return 127 * abs(Input)/Input;
		return 0;
}

float Controller() {
	/*
	if (Revolution < Input)
		Output = 10
	else
		Output = -10
	 */

	/*
	Error = Input - Revolution
	Proportion = Error
	Integral = Integral + Error * dTime
	Derivative = (Error - pError)/dTime
	Output = pK * Proportion + iK * Integral + dK * Derivative
	pError = Error
	 */

	Error = Input - Revolution;
	Output += Error * Gain;
	if (Error * pError < 0) {
		if (abs(pOutput - Output) > Tolerance)
			Output = pOutput;
		else
			Output = (pOutput + Output)/2;
		pOutput = Output;
	}
	pError = Error;
	return Output;
}

void Shoot(bool Button, int Power) {
	if (Button) {
		motor[LauncherLeft] = Power; motor[LauncherRight] = Power;
	}
	else {
		motor[LauncherLeft] = 0; motor[LauncherRight] = 0;
	}
}

int Steer(int Input, bool Direction) {
	if (Direction)
		return Input/16;
	return Input;
}

void Reload(bool Forward, bool Backward) {
	if (Forward)
		motor[Intake] = 127;
	else if (Backward)
		motor[Intake] = -127;
	else
		motor[Intake] = 0;
}

void Debugger(bool Enable) {
	motor[Debug] = 127;
}

task second() {
	while (true) {
		Input = 70;
		Revolution = SensorValue[dgtl1];
		Output = Controller();
		wait1Msec(dTime * 1000);
	}
}

task main() {
	int LVertical = 0, RVertical = 0;
	bool Debug = true;
	startTask(second);
	while (true) {
		Reload(vexRT[Btn5D], vexRT[Btn7D]);
		Shoot(vexRT[Btn6D], Controller());
		if (vexRT[Btn7L])
			Debug = !Debug;
		Debugger(Debug);
		LVertical = Threshold(vexRT[Ch3]);
		RVertical = Threshold(vexRT[Ch2]);
		LVertical = Steer(LVertical, vexRT[Btn5U]);
		RVertical = Steer(RVertical, vexRT[Btn6U]);
		LVertical = Sensitivity(LVertical, RVertical);
		RVertical = Sensitivity(RVertical, LVertical);
		Drive(LVertical, RVertical);
	}
}
